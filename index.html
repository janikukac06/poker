<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Falatka Poker</title>
    <style>
        /* Main layout */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #006633;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        .table {
            width: 800px;
            height: 600px;
            background-color: #008844;
            border-radius: 200px;
            border: 15px solid #553311;
            position: relative;
            padding: 20px;
        }
        .robot, .player {
            position: absolute;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            color: white;
        }
        .robot-1 {
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
        }
        .robot-2 {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .robot-3 {
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
        }
        .player {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .cards {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .card {
            width: 60px;
            height: 80px;
            background-color: white;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            font-weight: bold;
            font-size: 30px;
        }
        .card-back {
            background-image: linear-gradient(45deg, #5a8cc5 25%, #36648b 25%, #36648b 50%, #5a8cc5 50%, #5a8cc5 75%, #36648b 75%, #36648b 100%);
            background-size: 20px 20px;
            color: transparent !important;
        }
        .player-info {
            margin-top: 5px;
        }
        .dealer-button {
            width: 30px;
            height: 30px;
            background-color: white;
            border-radius: 50%;
            color: black;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
        }
        .player .dealer-button {
            bottom: 60px;
            right: -15px;
        }
        .robot .dealer-button {
            top: 60px;
            right: -15px;
        }
        .blind {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
            font-size: 12px;
        }
        .small-blind {
            background-color: white;
            color: black;
        }
        .big-blind {
            background-color: red;
            color: white;
        }
        .player .blind {
            bottom: 60px;
            left: -15px;
        }
        .robot .blind {
            top: 60px;
            left: -15px;
        }
        .bet-amount {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            color: yellow;
        }
        .player .bet-amount {
            top: -30px;
        }
        .robot .bet-amount {
            bottom: -30px;
        }
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .active-player {
            border: 3px solid red;
            border-radius: 10px;
            padding: 5px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        .thinking {
            position: absolute;
            font-weight: bold;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
        }
        .robot .thinking {
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
        }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            display: none;
            text-align: center;
            z-index: 100;
            max-width: 80%;
        }
        .pot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }
        .pot p {
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .pot .cards {
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        .red-card {
            color: red !important;
        }
        /* Adjust sizes for smaller viewport */
        @media (max-width: 914px), (max-height: 412px) {
            .table {
                width: 600px;
                height: 320px;
                border-radius: 120px;
            }
            
            .robot, .player {
                font-size: 12px;
                padding: 5px;
                width: 110px;
            }
            
            .card {
                width: 30px;
                height: 45px;
                font-size: 14px;
            }
            
            .dealer-button, .blind {
                width: 16px;
                height: 16px;
                font-size: 10px;
            }
            
            .action-buttons {
                bottom: 65px;
            }
            
            .controls {
                bottom: -40px;
            }
            
            .pot {
                top: 42%;
            }
        }
        
        /* Fullscreen button styles */
        .fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 16px;
        }
        
        /* Style adjustments for fullscreen mode */
        :fullscreen, ::backdrop {
            background-color: #006633;
        }
        
        /* Media queries for mobile */
        @media screen and (max-width: 914px) {
            body {
                height: 100svh; /* Use small viewport height for mobile */
            }
            
            .table {
                width: 100%;
                height: auto;
                aspect-ratio: 2 / 1;
                border-width: 8px;
                padding: 10px;
            }
            
            .card {
                width: 40px;
                height: 55px;
                font-size: 20px;
            }
        }

        /* Button container styles */
        .buttons-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 10px auto 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        /* Button styles */
        button {
            padding: 8px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: none;
            background-color: #336699;
            color: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: #4477aa;
        }

        #check-button { background-color: #339933; }
        #check-button:hover { background-color: #44aa44; }

        #call-button { background-color: #3377bb; }
        #call-button:hover { background-color: #4488cc; }

        #raise-button { background-color: #aa6633; }
        #raise-button:hover { background-color: #bb7744; }

        #fold-button { background-color: #993333; }
        #fold-button:hover { background-color: #aa4444; }
    </style>
    <script>
        // Card definitions
        const suits = ['♥', '♦', '♠', '♣'];
        const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        let deck = [];
        let communityCards = [];
        
        // Players array - contains all players (human and robots)
        let players = [
            {
                name: "Falatka",
                isRobot: false,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 0, // Bottom position
                folded: false,
                isActedInCurrentRound: false,
                element: '.player',
                dealerButton: '.player .dealer-button',
                blindIndicator: '.player .blind',
                betIndicator: '.player .bet-amount'
            },
            {
                name: "Robot1",
                isRobot: true,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 1, // Left position
                folded: false,
                isActedInCurrentRound: false,
                element: '.robot-1',
                dealerButton: '.robot-1 .dealer-button',
                blindIndicator: '.robot-1 .blind',
                betIndicator: '.robot-1 .bet-amount',
                thinking: '.robot-1 .thinking'
            },
            {
                name: "Robot2",
                isRobot: true,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 2, // Top position
                folded: false,
                isActedInCurrentRound: false,
                element: '.robot-2',
                dealerButton: '.robot-2 .dealer-button',
                blindIndicator: '.robot-2 .blind',
                betIndicator: '.robot-2 .bet-amount',
                thinking: '.robot-2 .thinking'
            },
            {
                name: "Robot3",
                isRobot: true,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 3, // Right position
                folded: false,
                isActedInCurrentRound: false,
                element: '.robot-3',
                dealerButton: '.robot-3 .dealer-button',
                blindIndicator: '.robot-3 .blind',
                betIndicator: '.robot-3 .bet-amount',
                thinking: '.robot-3 .thinking'
            }
        ];
        
        // Game state
        let dealerIndex = 0;      // Index of the dealer in the players array
        let smallBlindIndex = 0;  // Index of the small blind in the players array
        let bigBlindIndex = 0;    // Index of the big blind in the players array
        let activePlayerIndex = 0;// Index of the active player in the players array
        let smallBlindAmount = 10;
        let bigBlindAmount = 20;
        let potAmount = 0;
        let currentBettingRound = 'none'; // none, preflop, flop, turn, river, showdown
        let isPlayerTurn = false; // Track if it's the human player's turn
        
        // Create and shuffle the deck
        function initializeDeck() {
            deck = [];
            // Create the deck
            for (let suit of suits) {
                for (let value of values) {
                    deck.push({ suit, value });
                }
            }
            // Shuffle the deck
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        // Deal cards to players
        function dealCards() {
            // Reset hands and community cards
            communityCards = [];
            
            // Reset player cards
            players.forEach(player => {
                player.cards = [];
                player.folded = false;
            });
            
            // Deal 2 cards to each player
            for (let i = 0; i < 2; i++) {
                for (let player of players) {
                    player.cards.push(deck.pop());
                }
            }
            
            // Update the UI
            updatePlayerCards();
            console.log("Players after dealing cards:", JSON.parse(JSON.stringify(players)));
        }
        
        // Start a new game
        function startNewGame() {
            // Reset game state
            potAmount = 0;
            
            // Clear community cards
            communityCards = [];
            updateCommunityCards();
            
            // Reset all player chips and bets
            players.forEach(player => {
                player.chips = 1000;
                player.bet = 0;
                player.folded = false;
                player.isActedInCurrentRound = false;
            });
            
            // Randomly select dealer position
            dealerIndex = Math.floor(Math.random() * players.length);
            
            // Set small blind and big blind positions (clockwise)
            smallBlindIndex = (dealerIndex + 1) % players.length;
            bigBlindIndex = (dealerIndex + 2) % players.length;
            
            // Set the first player to act (after big blind)
            activePlayerIndex = (bigBlindIndex + 1) % players.length;
            
            // Initialize the deck and deal cards
            initializeDeck();
            dealCards();
            updatePlayerCards(); // Reset card displays including robot card backgrounds
            
            // Place blinds
            placeBlinds();
            
            // Update UI
            updateChips();
            updateDealerButton();
            updateBlinds();
            
            // Start preflop betting round
            currentBettingRound = 'preflop';
            
            // Set active player
            setActivePlayer(activePlayerIndex);
            
            // If robot is first to act, trigger its action
            if (players[activePlayerIndex].isRobot) {
                robotActionWithDelay();
            }
            
            // Enable betting buttons if it's player's turn
            updateActionButtons();
        }
        
        // Place blinds based on dealer position
        function placeBlinds() {
            // Reset all bets
            players.forEach(player => {
                player.bet = 0;
                player.isActedInCurrentRound = false;
            });
            
            // Small blind
            potAmount += smallBlindAmount;
            players[smallBlindIndex].chips -= smallBlindAmount;
            players[smallBlindIndex].bet = smallBlindAmount;
            
            // Big blind
            potAmount += bigBlindAmount;
            players[bigBlindIndex].chips -= bigBlindAmount;
            players[bigBlindIndex].bet = bigBlindAmount;
            
            updateChips();
            console.log("Players after placing blinds:", JSON.parse(JSON.stringify(players)));
        }
        
        // Update the chips display
        function updateChips() {
            // Update player chips display
            players.forEach(player => {
                if (!player.isRobot) {
                    document.querySelector('.player-info').textContent = `${player.name}: ${player.chips}`;
                } else {
                    document.querySelector(`${player.element} p`).textContent = `${player.name}: ${player.chips}`;
                }
                
                // Update bet amounts
                let betElement = document.querySelector(player.betIndicator);
                if (player.bet > 0) {
                    betElement.textContent = player.bet;
                    betElement.style.display = 'block';
                } else {
                    betElement.style.display = 'none';
                }
            });
            
            // Update pot amount
            document.querySelector('.pot p').textContent = `Pot: ${potAmount}`;
        }
        
        // Update dealer button position
        function updateDealerButton() {
            // Hide all dealer buttons
            players.forEach(player => {
                document.querySelector(player.dealerButton).style.display = 'none';
            });
            
            // Show dealer button for the dealer
            document.querySelector(players[dealerIndex].dealerButton).style.display = 'flex';
        }
        
        // Update blinds indicators
        function updateBlinds() {
            // Hide all blind indicators first
            players.forEach(player => {
                document.querySelector(player.blindIndicator).style.display = 'none';
            });
            
            // Show small blind indicator
            let sbIndicator = document.querySelector(players[smallBlindIndex].blindIndicator);
            sbIndicator.textContent = 'SB';
            sbIndicator.classList.add('small-blind');
            sbIndicator.classList.remove('big-blind');
            sbIndicator.style.display = 'flex';
            
            // Show big blind indicator
            let bbIndicator = document.querySelector(players[bigBlindIndex].blindIndicator);
            bbIndicator.textContent = 'BB';
            bbIndicator.classList.remove('small-blind');
            bbIndicator.classList.add('big-blind');
            bbIndicator.style.display = 'flex';
        }
        
        // Set active player (visual indicator)
        function setActivePlayer(index) {
            console.log(`setActivePlayer: Setting player ${players[index].name} as active`);
            // Prevent setting a folded player as active
            if (players[index].folded) {
                console.log(`Attempted to set folded player ${players[index].name} as active. Finding next valid player.`);
                // Find the next non-folded player
                let nextValidIndex = index;
                let count = 0;
                
                // Loop through players until finding one that hasn't folded
                // Limited by player count to prevent infinite loop
                while (count < players.length) {
                    nextValidIndex = (nextValidIndex + 1) % players.length;
                    if (!players[nextValidIndex].folded) {
                        break;
                    }
                    count++;
                }
                
                // If all players are folded except one, the game is over
                if (count >= players.length - 1) {
                    const winner = players.find(p => !p.folded);
                    if (winner) {
                        winner.chips += potAmount;
                        // Reset all player bets
                        players.forEach(player => {
                            player.bet = 0;
                        });
                        updateChips();
                        showGameMessage(`${winner.name} wins ${potAmount} chips!`);
                        potAmount = 0;
                        console.log("Game over, everyone folded except:", winner.name);
                        document.querySelector('.action-buttons').style.display = 'none';
                        return;
                    }
                }
                
                // Set the non-folded player as active
                index = nextValidIndex;
                console.log(`Setting next valid player ${players[index].name} as active instead`);
            }
            
            activePlayerIndex = index;
            isPlayerTurn = !players[activePlayerIndex].isRobot;
            
            // Remove active-player class from all players
            players.forEach(player => {
                document.querySelector(player.element).classList.remove('active-player');
            });
            
            // Hide all thinking indicators
            players.filter(p => p.isRobot).forEach(robot => {
                document.querySelector(robot.thinking).style.display = 'none';
            });
            
            // Add active-player class to the active player
            document.querySelector(players[activePlayerIndex].element).classList.add('active-player');
            
            // If active player is a robot, show thinking indicator
            if (players[activePlayerIndex].isRobot) {
                document.querySelector(players[activePlayerIndex].thinking).style.display = 'block';
                
                // Disable player action buttons while robot is thinking
                document.querySelectorAll('.action-buttons button').forEach(button => {
                    button.disabled = true;
                });
            } else {
                // Enable player action buttons
                updateActionButtons();
            }
        }
        
        // Move to the next player in turn
        function nextPlayer() {
            console.log("nextPlayer");
            // Mark current player as having acted in this round
            players[activePlayerIndex].isActedInCurrentRound = true;
            console.log(`Player ${players[activePlayerIndex].name} has acted this round`);
                        
            // Find next player that hasn't folded
            let nextIndex = (activePlayerIndex + 1) % players.length;
            let count = 0;
            
            // Skip folded players, but prevent infinite loops
            while (players[nextIndex].folded && count < players.length) {
                nextIndex = (nextIndex + 1) % players.length;
                count++;
            }
            
            // Check if all non-folded players have called the highest bet
            const highestBet = Math.max(...players.map(p => p.bet));
            const nonFoldedPlayers = players.filter(p => !p.folded);
            
            // If all active players have the same bet amount, move to next round
            const allBetsEqual = nonFoldedPlayers.every(p => p.bet === highestBet);

            // Check if all non-folded players have acted in this round
            const allPlayersActed = nonFoldedPlayers.every(p => p.isActedInCurrentRound);
            
            console.log("All bets equal:", allBetsEqual, "All players acted:", allPlayersActed);
            console.log("Active players:", nonFoldedPlayers.map(p => `${p.name}: bet=${p.bet}, acted=${p.isActedInCurrentRound}`));
            
            if (allBetsEqual && allPlayersActed) {
                // All players have matched the bet, move to next round
                console.log("All bets equal, advancing to next round");
                advanceToNextRound();
                return;
            }
            
            setActivePlayer(nextIndex);
            console.log("Next player:", nextIndex, "Active player is robot:", players[nextIndex].isRobot);
            
            // If next player is a robot, trigger its action
            if (players[nextIndex].isRobot) {
                robotActionWithDelay();
            }
        }

        // Update player cards in the UI
        function updatePlayerCards() {
            // Update human player's cards
            const humanPlayer = players.find(p => !p.isRobot);
            const playerCardElements = document.querySelectorAll('.player .card');
            
            if (humanPlayer.folded) {
                // If player has folded, show empty cards with transparent background
                playerCardElements.forEach(card => {
                    card.textContent = '';
                    card.classList.remove('red-card');
                    card.style.backgroundImage = 'none';
                    card.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                    card.style.color = '';
                });
            } else if (humanPlayer.cards.length === 2) {
                playerCardElements[0].textContent = `${humanPlayer.cards[0].value}${humanPlayer.cards[0].suit}`;
                playerCardElements[1].textContent = `${humanPlayer.cards[1].value}${humanPlayer.cards[1].suit}`;
                
                // Reset any background styles from previous games/folds
                playerCardElements.forEach(card => {
                    card.style.backgroundImage = '';
                    card.style.backgroundColor = '';
                });
                
                // Apply color for hearts and diamonds
                playerCardElements.forEach((cardEl, index) => {
                    if (humanPlayer.cards[index].suit === '♥' || humanPlayer.cards[index].suit === '♦') {
                        cardEl.classList.add('red-card');
                    } else {
                        cardEl.classList.remove('red-card');
                    }
                });
            } else {
                playerCardElements.forEach(card => {
                    card.textContent = '?';
                    card.classList.remove('red-card');
                    // Reset any background styles
                    card.style.backgroundImage = '';
                    card.style.backgroundColor = '';
                });
            }
            
            // Set robot cards to hidden state (unless revealed)
            players.filter(p => p.isRobot).forEach((robot, robotIndex) => {
                const robotCards = document.querySelectorAll(`${robot.element} .card`);
                
                if (robot.folded) {
                    // If robot has folded, show empty cards
                    robotCards.forEach(card => {
                        card.textContent = '';
                        card.classList.remove('card-back');
                        card.classList.remove('red-card');
                        card.style.backgroundImage = 'none';
                        card.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                        card.style.color = '';
                    });
                } else {
                    // If robot is active, show card backs with gradient
                    robotCards.forEach(card => {
                        card.textContent = '';
                        card.classList.add('card-back');
                        card.classList.remove('red-card');
                        // Clear any inline styles that might override the card-back class
                        card.style.backgroundImage = '';
                        card.style.backgroundColor = '';
                        card.style.color = '';
                    });
                }
            });
        }
        
        // Player actions
        function playerCheck() {
            // Player can only check if no one has bet more
            const highestBet = Math.max(...players.map(p => p.bet));
            
            if (players[activePlayerIndex].bet >= highestBet) {
                console.log("Player checks");
                nextPlayer(); // Move to next player's turn
            }
        }
        
        function playerCall() {
            const humanPlayerIndex = players.findIndex(p => !p.isRobot);
            const highestBet = Math.max(...players.map(p => p.bet));
            const callAmount = highestBet - players[humanPlayerIndex].bet;
            
            // Update chips and bet
            potAmount += callAmount;
            players[humanPlayerIndex].chips -= callAmount;
            players[humanPlayerIndex].bet = highestBet;
            
            updateChips();
            console.log("Player calls, new bet:", players[humanPlayerIndex].bet);
            nextPlayer();
        }
        
        function playerRaise() {
            const humanPlayerIndex = players.findIndex(p => !p.isRobot);
            const highestBet = Math.max(...players.map(p => p.bet));
            const raiseAmount = bigBlindAmount;
            const totalBet = highestBet + raiseAmount;
            const amountToAdd = totalBet - players[humanPlayerIndex].bet;
            
            // Update chips and bet
            potAmount += amountToAdd;
            players[humanPlayerIndex].chips -= amountToAdd;
            players[humanPlayerIndex].bet = totalBet;
            
            updateChips();
            console.log("Player raises to:", players[humanPlayerIndex].bet);
            
            nextPlayer(); // Move to next player
        }
        
        function playerFold() {
            const humanPlayerIndex = players.findIndex(p => !p.isRobot);
            players[humanPlayerIndex].folded = true;
            console.log("Player folds");

            // Immediately update the visual representation of cards
            updatePlayerCards();
            
            // Check if only one player remains
            const activePlayers = players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                // Award pot to the remaining player
                activePlayers[0].chips += potAmount;
                
                // Clear the pot
                potAmount = 0;
                players.forEach(player => player.bet = 0);
                
                updateChips();
                showGameMessage(`${activePlayers[0].name} wins ${potAmount} chips!`);
                potAmount = 0;
                
                // Hide action buttons
                document.querySelector('.action-buttons').style.display = 'none';
            } else {
                nextPlayer(); // Move to next player
            }
        }
        
        // Apply a random delay to robot's action
        function robotActionWithDelay() {
            console.log("robotActionWithDelay");
            // Only proceed if active player is a robot
            if (!players[activePlayerIndex].isRobot) return;
            
            const delay = 1000 + Math.random() * 1000; // 1-2 second delay
            setTimeout(robotAction, delay);
        }
        
        // Simple robot AI
        function robotAction() {
            console.log("robotAction");
            if (!players[activePlayerIndex].isRobot) return;
            
            const robot = players[activePlayerIndex];
            const highestBet = Math.max(...players.map(p => p.bet));
            const callAmount = highestBet - robot.bet;
            
            // Simple AI logic - randomize decisions
            const random = Math.random();
            
            if (callAmount === 0) {
                // Can check
                if (random < 0.7) {
                    // Check (70% chance)
                    console.log(`${robot.name} checks`);
                    // Robot action flag is set in nextPlayer()
                    nextPlayer();
                } else {
                    // Raise (30% chance)
                    console.log(`${robot.name} raises`);
                    const raiseAmount = bigBlindAmount;
                    potAmount += raiseAmount;
                    robot.chips -= raiseAmount;
                    robot.bet += raiseAmount;
                    
                    // When robot raises, all other players need to act again
                    players.forEach(player => {
                        if (player !== robot && !player.folded) {
                            player.isActedInCurrentRound = false;
                        }
                    });
                    
                    updateChips();
                    console.log("Robot state after raising:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                }
            } else {
                // Need to call or raise
                if (callAmount >= robot.chips) {
                    // All-in
                    console.log(`${robot.name} is all-in`);
                    potAmount += robot.chips;
                    robot.bet += robot.chips;
                    robot.chips = 0;
                    updateChips();
                    console.log("Robot state after going all-in:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                } else if (random < 0.5) {
                    // Fold (50% chance if need to call)
                    console.log(`${robot.name} folds`);
                    robot.folded = true;
                    updatePlayerCards();
                    
                    // Check if only one player remains
                    const activePlayers = players.filter(p => !p.folded);
                    if (activePlayers.length === 1) {
                        // Award pot to the remaining player
                        activePlayers[0].chips += potAmount;
                        
                        updateChips();
                        showGameMessage(`${activePlayers[0].name} wins ${potAmount} chips!`);
                        potAmount = 0;
                        
                        // Hide action buttons
                        document.querySelector('.action-buttons').style.display = 'none';
                        
                        return;
                    }
                    
                    nextPlayer();
                } else if (random < 0.9) {
                    // Call (40% chance if need to call)
                    console.log(`${robot.name} calls ${callAmount}`);
                    potAmount += callAmount;
                    robot.chips -= callAmount;
                    robot.bet = highestBet;
                    updateChips();
                    console.log("Robot state after calling:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                } else {
                    // Raise (10% chance if need to call)
                    console.log(`${robot.name} raises`);
                    const raiseAmount = callAmount + bigBlindAmount;
                    
                    if (raiseAmount >= robot.chips) {
                        // All-in
                        potAmount += robot.chips;
                        robot.bet += robot.chips;
                        robot.chips = 0;
                    } else {
                        potAmount += raiseAmount;
                        robot.chips -= raiseAmount;
                        robot.bet = highestBet + bigBlindAmount;
                    }
                    
                    // When robot raises, all other players need to act again
                    players.forEach(player => {
                        if (player !== robot && !player.folded) {
                            player.isActedInCurrentRound = false;
                        }
                    });
                    
                    updateChips();
                    console.log("Robot state after raising:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                }
            }
        }
        
        // Advance to the next betting round
        function advanceToNextRound() {
            console.log("advanceToNextRound");

            // Reset current bets and acted flags
            players.forEach(player => {
                player.bet = 0;
                player.isActedInCurrentRound = false;
            });
            
            switch (currentBettingRound) {
                case 'preflop':
                    // Deal the flop
                    dealFlop();
                    currentBettingRound = 'flop';
                    break;
                case 'flop':
                    // Deal the turn
                    dealTurn();
                    currentBettingRound = 'turn';
                    break;
                case 'turn':
                    // Deal the river
                    dealRiver();
                    currentBettingRound = 'river';
                    break;
                case 'river':
                    // Show down - evaluate hands and determine winner
                    currentBettingRound = 'showdown';
                    showdown();
                    return;
            }
            
            updateChips();
            
            // Set active player (acts first player after the dealer after the flop)
            if (currentBettingRound !== 'showdown') {
                // First to act after the flop is the player after the dealer
                const nextPlayerIndex = (dealerIndex + 1) % players.length;
                setActivePlayer(nextPlayerIndex);
                
                // If the active player is a robot, trigger its action
                console.log("Active player after advancing round:", players[activePlayerIndex].name);
                if (players[activePlayerIndex].isRobot) {
                    console.log("First to act is a robot, triggering robot action");
                    robotActionWithDelay();
                }
            }
            
            updateActionButtons();
            console.log("Advanced to betting round:", currentBettingRound);
            console.log("Players state:", JSON.parse(JSON.stringify(players)));
        }
        
        // Update action buttons based on game state
        function updateActionButtons() {
            const actionButtons = document.querySelector('.action-buttons');
            
            if (currentBettingRound === 'none' || currentBettingRound === 'showdown') {
                actionButtons.style.display = 'none';
                return;
            } else {
                actionButtons.style.display = 'flex';
            }
            
            // If it's not player's turn, hide all buttons
            if (!isPlayerTurn) {
                document.querySelectorAll('.action-buttons button').forEach(button => {
                    button.style.display = 'none';
                });
                return;
            } else {
                // Make sure all buttons are visible by default and explicitly enabled
                document.querySelectorAll('.action-buttons button').forEach(button => {
                    button.style.display = 'inline-block';
                    button.disabled = false;
                });
            }
            
            // Get player and highest bet information
            const player = players.find(p => !p.isRobot);
            const highestBet = Math.max(...players.map(p => p.bet));
            const playerBet = player.bet;
            const amountToCall = highestBet - playerBet;
            
            // Show/hide buttons based on context
            const checkButton = document.getElementById('check-button');
            const callButton = document.getElementById('call-button');
            const raiseButton = document.getElementById('raise-button');
            const foldButton = document.getElementById('fold-button');
            
            // Check button - only shown if no one has bet more than player
            checkButton.style.display = playerBet < highestBet ? 'none' : 'inline-block';
            if (checkButton.style.display !== 'none') {
                checkButton.disabled = false;
            }
            
            // Call button - only shown if there's something to call and player has enough chips
            callButton.style.display = (playerBet >= highestBet || player.chips < amountToCall) ? 'none' : 'inline-block';
            if (callButton.style.display !== 'none') {
                callButton.disabled = false;
            }
            
            // Update call button text to show amount
            if (amountToCall > 0) {
                callButton.textContent = `Call ${amountToCall}`;
            } else {
                callButton.textContent = 'Call';
            }
            
            // Raise button - only shown if player has enough chips to raise
            const minRaiseAmount = Math.max(bigBlindAmount, highestBet * 2 - playerBet);
            raiseButton.style.display = player.chips < minRaiseAmount ? 'none' : 'inline-block';
            if (raiseButton.style.display !== 'none') {
                raiseButton.disabled = false;
            }
            
            // Fold button - only shown if there's something to fold to
            foldButton.style.display = highestBet <= playerBet ? 'none' : 'inline-block';
            if (foldButton.style.display !== 'none') {
                foldButton.disabled = false;
            }
        }
        
        // Reveal the robot's cards
        function revealRobotCards() {
            const robotCardElements = document.querySelectorAll('.robot .card');
            
            // Reset all cards to hide first
            robotCardElements.forEach(card => {
                card.innerHTML = '?';
                card.classList.add('card-back');
                card.style.color = 'white';
            });
            
            // Now reveal the correct cards for each robot
            for (let r = 0; r < 3; r++) {
                const robotHand = players[r+1].cards;
                if (!robotHand || robotHand.length === 0) continue;
                
                for (let c = 0; c < robotHand.length; c++) {
                    const card = robotHand[c];
                    const cardElement = document.querySelector(`.robot-${r+1} .card:nth-child(${c+1})`);
                    
                    if (cardElement && card) {
                        const color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                        cardElement.innerHTML = `${card.value}${card.suit}`;
                        cardElement.style.color = color;
                        cardElement.classList.remove('card-back');
                    }
                }
            }
        }

        // Show game result message
        function showGameMessage(message) {
            const gameMessage = document.querySelector('.game-message');
            // Clear any previous content
            gameMessage.innerHTML = '';
            
            // Add message text
            const messageText = document.createElement('div');
            messageText.textContent = message;
            gameMessage.appendChild(messageText);
            
            // Add a button to close the message and a button to start a new game
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '15px';
            buttonContainer.style.display = 'flex';
            buttonContainer.style.justifyContent = 'center';
            buttonContainer.style.gap = '10px';
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.onclick = function() { 
                gameMessage.style.display = 'none';
            };
            closeBtn.style.padding = '5px 10px';
            closeBtn.style.backgroundColor = '#e74c3c';
            closeBtn.style.border = 'none';
            closeBtn.style.borderRadius = '3px';
            closeBtn.style.color = 'white';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.style.cursor = 'pointer';
            
            const newGameBtn = document.createElement('button');
            newGameBtn.textContent = 'New Game';
            newGameBtn.onclick = function() {
                gameMessage.style.display = 'none';
                startNewGame();
            };
            newGameBtn.style.padding = '5px 10px';
            newGameBtn.style.backgroundColor = '#2ecc71';
            newGameBtn.style.border = 'none';
            newGameBtn.style.borderRadius = '3px';
            newGameBtn.style.color = 'white';
            newGameBtn.style.fontWeight = 'bold';
            newGameBtn.style.cursor = 'pointer';
            
            buttonContainer.appendChild(closeBtn);
            buttonContainer.appendChild(newGameBtn);
            gameMessage.appendChild(buttonContainer);
            
            // Display the message
            gameMessage.style.display = 'block';
        }

        // Hand evaluation functions
        function evaluateHand(cards) {
            // Combine hole cards and community cards, then find best 5-card hand
            if (cards.length < 5) return { rank: 0, name: 'Invalid Hand', value: [] };
            
            // Sort cards by value (numerically, with face cards converted)
            const sortedCards = [...cards].sort((a, b) => {
                const valueA = cardValue(a.value);
                const valueB = cardValue(b.value);
                return valueB - valueA; // descending order
            });
            
            // Check for different hand types (from highest to lowest)
            let result = checkRoyalFlush(sortedCards);
            if (result.rank) return result;
            
            result = checkStraightFlush(sortedCards);
            if (result.rank) return result;
            
            result = checkFourOfAKind(sortedCards);
            if (result.rank) return result;
            
            result = checkFullHouse(sortedCards);
            if (result.rank) return result;
            
            result = checkFlush(sortedCards);
            if (result.rank) return result;
            
            result = checkStraight(sortedCards);
            if (result.rank) return result;
            
            result = checkThreeOfAKind(sortedCards);
            if (result.rank) return result;
            
            result = checkTwoPair(sortedCards);
            if (result.rank) return result;
            
            result = checkOnePair(sortedCards);
            if (result.rank) return result;
            
            // High card
            return {
                rank: 1,
                name: 'High Card',
                value: sortedCards.slice(0, 5).map(card => cardValue(card.value))
            };
        }
        
        // Convert card values to numeric values for comparison
        function cardValue(value) {
            switch (value) {
                case 'A': return 14;
                case 'K': return 13;
                case 'Q': return 12;
                case 'J': return 11;
                default: return parseInt(value);
            }
        }
        
        // Check for royal flush (A, K, Q, J, 10 of same suit)
        function checkRoyalFlush(cards) {
            const suits = ['♥', '♦', '♠', '♣'];
            
            for (let suit of suits) {
                const sameSuit = cards.filter(card => card.suit === suit);
                if (sameSuit.length >= 5) {
                    const values = sameSuit.map(card => cardValue(card.value));
                    if (values.includes(14) && values.includes(13) && values.includes(12) && 
                        values.includes(11) && values.includes(10)) {
                        return {
                            rank: 10,
                            name: 'Royal Flush',
                            value: [14, 13, 12, 11, 10]
                        };
                    }
                }
            }
            return { rank: 0 };
        }
        
        // Check for straight flush (5 consecutive cards of same suit)
        function checkStraightFlush(cards) {
            const suits = ['♥', '♦', '♠', '♣'];
            
            for (let suit of suits) {
                const sameSuit = cards.filter(card => card.suit === suit);
                if (sameSuit.length >= 5) {
                    const result = checkStraightInCards(sameSuit);
                    if (result.rank) {
                        return {
                            rank: 9,
                            name: 'Straight Flush',
                            value: result.value
                        };
                    }
                }
            }
            return { rank: 0 };
        }
        
        // Check for four of a kind
        function checkFourOfAKind(cards) {
            const valueCounts = getValueCounts(cards);
            
            for (let value in valueCounts) {
                if (valueCounts[value] === 4) {
                    const numValue = parseInt(value);
                    const kickers = cards
                        .filter(card => cardValue(card.value) !== numValue)
                        .map(card => cardValue(card.value))
                        .slice(0, 1);
                    
                    return {
                        rank: 8,
                        name: 'Four of a Kind',
                        value: [numValue, numValue, numValue, numValue, ...kickers]
                    };
                }
            }
            return { rank: 0 };
        }
        
        // Check for full house (three of a kind + pair)
        function checkFullHouse(cards) {
            const valueCounts = getValueCounts(cards);
            let threeOfAKind = null;
            let pair = null;
            
            // Find highest three of a kind
            for (let value in valueCounts) {
                const numValue = parseInt(value);
                if (valueCounts[value] >= 3) {
                    if (!threeOfAKind || numValue > threeOfAKind) {
                        threeOfAKind = numValue;
                    }
                }
            }
            
            // Find highest pair different from three of a kind
            if (threeOfAKind) {
                for (let value in valueCounts) {
                    const numValue = parseInt(value);
                    if (numValue !== threeOfAKind && valueCounts[value] >= 2) {
                        if (!pair || numValue > pair) {
                            pair = numValue;
                        }
                    }
                }
                
                if (pair) {
                    return {
                        rank: 7,
                        name: 'Full House',
                        value: [threeOfAKind, threeOfAKind, threeOfAKind, pair, pair]
                    };
                }
            }
            
            return { rank: 0 };
        }
        
        // Check for flush (5 cards of same suit)
        function checkFlush(cards) {
            const suits = ['♥', '♦', '♠', '♣'];
            
            for (let suit of suits) {
                const sameSuit = cards.filter(card => card.suit === suit);
                if (sameSuit.length >= 5) {
                    const values = sameSuit
                        .map(card => cardValue(card.value))
                        .sort((a, b) => b - a)
                        .slice(0, 5);
                    
                    return {
                        rank: 6,
                        name: 'Flush',
                        value: values
                    };
                }
            }
            return { rank: 0 };
        }
        
        // Check for straight (5 consecutive cards)
        function checkStraight(cards) {
            return checkStraightInCards(cards);
        }
        
        // Helper for checking straight in a set of cards
        function checkStraightInCards(cards) {
            // Get unique values sorted in descending order
            const values = [...new Set(cards.map(card => cardValue(card.value)))].sort((a, b) => b - a);
            
            // Special case: A-5-4-3-2 straight
            if (values.includes(14) && values.includes(5) && values.includes(4) && 
                values.includes(3) && values.includes(2)) {
                return {
                    rank: 5,
                    name: 'Straight',
                    value: [5, 4, 3, 2, 1] // Ace is treated as 1 in this case
                };
            }
            
            // Check for 5 consecutive values
            for (let i = 0; i <= values.length - 5; i++) {
                if (values[i] - values[i + 4] === 4) {
                    return {
                        rank: 5,
                        name: 'Straight',
                        value: values.slice(i, i + 5)
                    };
                }
            }
            
            return { rank: 0 };
        }
        
        // Check for three of a kind
        function checkThreeOfAKind(cards) {
            const valueCounts = getValueCounts(cards);
            
            for (let value in valueCounts) {
                if (valueCounts[value] === 3) {
                    const numValue = parseInt(value);
                    const kickers = cards
                        .filter(card => cardValue(card.value) !== numValue)
                        .map(card => cardValue(card.value))
                        .slice(0, 2);
                    
                    return {
                        rank: 4,
                        name: 'Three of a Kind',
                        value: [numValue, numValue, numValue, ...kickers]
                    };
                }
            }
            return { rank: 0 };
        }
        
        // Check for two pair
        function checkTwoPair(cards) {
            const valueCounts = getValueCounts(cards);
            const pairs = [];
            
            for (let value in valueCounts) {
                if (valueCounts[value] >= 2) {
                    pairs.push(parseInt(value));
                }
            }
            
            if (pairs.length >= 2) {
                // Sort pairs by value (descending)
                pairs.sort((a, b) => b - a);
                
                // Get highest two pairs
                const highestPairs = pairs.slice(0, 2);
                
                // Get kicker
                const kickers = cards
                    .filter(card => !highestPairs.includes(cardValue(card.value)))
                    .map(card => cardValue(card.value))
                    .slice(0, 1);
                
                return {
                    rank: 3,
                    name: 'Two Pair',
                    value: [highestPairs[0], highestPairs[0], highestPairs[1], highestPairs[1], ...kickers]
                };
            }
            
            return { rank: 0 };
        }
        
        // Check for one pair
        function checkOnePair(cards) {
            const valueCounts = getValueCounts(cards);
            
            for (let value in valueCounts) {
                if (valueCounts[value] >= 2) {
                    const numValue = parseInt(value);
                    const kickers = cards
                        .filter(card => cardValue(card.value) !== numValue)
                        .map(card => cardValue(card.value))
                        .slice(0, 3);
                    
                    return {
                        rank: 2,
                        name: 'One Pair',
                        value: [numValue, numValue, ...kickers]
                    };
                }
            }
            return { rank: 0 };
        }
        
        // Helper to count card values
        function getValueCounts(cards) {
            const counts = {};
            
            cards.forEach(card => {
                const value = cardValue(card.value);
                counts[value] = (counts[value] || 0) + 1;
            });
            
            return counts;
        }
        
        // Compare two hands to determine the winner
        function compareHands(hand1, hand2) {
            // First compare by rank
            if (hand1.rank !== hand2.rank) {
                return hand1.rank - hand2.rank;
            }
            
            // If ranks are equal, compare individual card values
            for (let i = 0; i < hand1.value.length; i++) {
                if (hand1.value[i] !== hand2.value[i]) {
                    return hand1.value[i] - hand2.value[i];
                }
            }
            
            // If all card values are equal, it's a tie
            return 0;
        }
        
        // Determine the best 5-card hand from 7 cards (2 hole cards + 5 community cards)
        function getBestHand(holeCards, communityCards) {
            const allCards = [...holeCards, ...communityCards];
            
            // Generate all possible 5-card combinations
            const combinations = [];
            
            // We need to choose 5 cards from 7 cards (C(7,5) = 21 combinations)
            for (let i = 0; i < allCards.length - 4; i++) {
                for (let j = i + 1; j < allCards.length - 3; j++) {
                    for (let k = j + 1; k < allCards.length - 2; k++) {
                        for (let l = k + 1; l < allCards.length - 1; l++) {
                            for (let m = l + 1; m < allCards.length; m++) {
                                combinations.push([allCards[i], allCards[j], allCards[k], allCards[l], allCards[m]]);
                            }
                        }
                    }
                }
            }
            
            // Evaluate each combination and find the best hand
            let bestHand = null;
            
            for (let combo of combinations) {
                const evaluation = evaluateHand(combo);
                
                if (!bestHand || compareHands(evaluation, bestHand) > 0) {
                    bestHand = evaluation;
                }
            }
            
            return bestHand;
        }
        
        // Showdown - determine winner
        function showdown() {
            console.log("Showdown round");
            currentBettingRound = 'showdown';

            // Hide action buttons during showdown
            document.querySelector('.action-buttons').style.display = 'none';

            // Reveal all robot cards
            revealRobotCards();
            
            // Evaluate all hands of non-folded players
            const activePlayers = players.filter(p => !p.folded);
            const evaluations = [];
            
            activePlayers.forEach(player => {
                const bestHand = getBestHand(player.cards, communityCards);
                evaluations.push({
                    player,
                    hand: bestHand
                });
                console.log(`${player.name}'s hand: `, JSON.parse(JSON.stringify(bestHand.name)));
            });
            
            // Sort evaluations by hand strength (descending)
            evaluations.sort((a, b) => compareHands(a.hand, b.hand));
            
            // Check for split pot - find all players with the best hand
            const bestHandRank = evaluations[evaluations.length - 1].hand;
            const winners = evaluations.filter(eval => compareHands(eval.hand, bestHandRank) === 0);
            
            let message = '';
            
            // Handle split pot if there are multiple winners
            if (winners.length > 1) {
                // Split the pot evenly
                const splitAmount = Math.floor(potAmount / winners.length);
                // Calculate remainder (if any)
                const remainder = potAmount % winners.length;
                
                // Award split amount to each winner
                winners.forEach(winner => {
                    winner.player.chips += splitAmount;
                });
                
                // If there's a remainder, give it to the first player after the dealer
                // (mimics what would happen in a real game)
                if (remainder > 0) {
                    // Find the first winner after the dealer position
                    let remainderWinner = null;
                    let lowestPositionAfterDealer = Number.MAX_VALUE;
                    
                    winners.forEach(winner => {
                        // Calculate position relative to dealer
                        const playerIndex = players.indexOf(winner.player);
                        let relativePos = playerIndex - dealerIndex;
                        if (relativePos <= 0) {
                            relativePos += players.length; // Wrap around
                        }
                        
                        if (relativePos < lowestPositionAfterDealer) {
                            lowestPositionAfterDealer = relativePos;
                            remainderWinner = winner.player;
                        }
                    });
                    
                    if (remainderWinner) {
                        remainderWinner.chips += remainder;
                        message = `Split pot! ${winners.map(w => w.player.name).join(', ')} split ${potAmount} chips with ${winners[0].hand.name}! ${remainderWinner.name} gets ${remainder} extra chip${remainder > 1 ? 's' : ''}.`;
                    }
                } else {
                    message = `Split pot! ${winners.map(w => w.player.name).join(', ')} split ${potAmount} chips with ${winners[0].hand.name}!`;
                }
            } else {
                // Single winner case (no changes to original logic)
                const winner = winners[0].player;
                const winningHand = winners[0].hand;
                winner.chips += potAmount;
                message = `${winner.name} wins ${potAmount} chips with ${winningHand.name}!`;
            }
            
            // Reset all player bets
            players.forEach(p => {
                p.bet = 0;
            });
            
            updateChips();
            showGameMessage(message);
            potAmount = 0;
        }
        
        // Deal the flop (first 3 community cards)
        function dealFlop() {
            // Burn a card (discard)
            deck.pop();
            
            // Deal 3 community cards
            for (let i = 0; i < 3; i++) {
                communityCards.push(deck.pop());
            }
            
            updateCommunityCards();
            console.log("Flop dealt:", JSON.parse(JSON.stringify(communityCards)));
        }

        // Deal the turn (4th community card)
        function dealTurn() {
            // Burn a card
            deck.pop();
            
            // Deal the turn card
            communityCards.push(deck.pop());
            
            updateCommunityCards();
            console.log("Turn dealt:", JSON.parse(JSON.stringify(communityCards)));
        }

        // Deal the river (5th community card)
        function dealRiver() {
            // Burn a card
            deck.pop();
            
            // Deal the river card
            communityCards.push(deck.pop());
            
            updateCommunityCards();
            console.log("River dealt:", JSON.parse(JSON.stringify(communityCards)));
        }
        
        // Update community cards in the UI
        function updateCommunityCards() {
            const communityCardElements = document.querySelectorAll('.pot .card');
            
            // Show revealed community cards, keep others hidden
            for (let i = 0; i < communityCardElements.length; i++) {
                if (i < communityCards.length) {
                    const card = communityCards[i];
                    communityCardElements[i].textContent = `${card.value}${card.suit}`;
                    
                    // Apply color for hearts and diamonds
                    if (card.suit === '♥' || card.suit === '♦') {
                        communityCardElements[i].style.color = 'red';
                    } else {
                        communityCardElements[i].style.color = 'black';
                    }
                } else {
                    // Clear card content when no card exists
                    communityCardElements[i].textContent = '';
                    communityCardElements[i].style.color = 'black';
                }
            }
        }

        // Initialize the game when the page loads
        window.onload = function() {
            startNewGame();
        };
    </script>
    
    <!-- Add fullscreen toggle function -->
    <script>
        // Fullscreen API functions
        function toggleFullScreen() {
            if (!document.fullscreenElement &&    // Standard
                !document.mozFullScreenElement && // Firefox
                !document.webkitFullscreenElement && // Chrome, Safari, Opera
                !document.msFullscreenElement) {  // IE/Edge
                
                // Request fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) { // Firefox
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) { // Chrome, Safari, Opera
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) { // IE/Edge
                    document.documentElement.msRequestFullscreen();
                }
                
                // Update button text
                document.getElementById('fullscreen-btn').textContent = 'Exit Fullscreen';
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { // Firefox
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { // Chrome, Safari, Opera
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE/Edge
                    document.msExitFullscreen();
                }
                
                // Update button text
                document.getElementById('fullscreen-btn').textContent = 'Fullscreen';
            }
        }
        
        // Listen for fullscreen change events to update button text
        document.addEventListener('fullscreenchange', updateFullscreenButtonText);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButtonText);
        document.addEventListener('mozfullscreenchange', updateFullscreenButtonText);
        document.addEventListener('MSFullscreenChange', updateFullscreenButtonText);
        
        function updateFullscreenButtonText() {
            const button = document.getElementById('fullscreen-btn');
            if (document.fullscreenElement || 
                document.webkitFullscreenElement || 
                document.mozFullScreenElement ||
                document.msFullscreenElement) {
                button.textContent = 'Exit Fullscreen';
            } else {
                button.textContent = 'Fullscreen';
            }
        }
        
        // Initialize fullscreen button when document is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Check if Fullscreen API is supported
            if (document.documentElement.requestFullscreen || 
                document.documentElement.mozRequestFullScreen || 
                document.documentElement.webkitRequestFullscreen || 
                document.documentElement.msRequestFullscreen) {
                // Create the fullscreen button if supported
                const fullscreenBtn = document.createElement('button');
                fullscreenBtn.id = 'fullscreen-btn';
                fullscreenBtn.className = 'fullscreen-btn';
                fullscreenBtn.textContent = 'Fullscreen';
                fullscreenBtn.addEventListener('click', toggleFullScreen);
                document.body.appendChild(fullscreenBtn);
            }
        });
    </script>
</head>
<body>
    <div class="table">
        <div class="robot robot-1">
            <p>Robot: 1000</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
            <div class="thinking">Thinking...</div>
        </div>
        <div class="robot robot-2">
            <p>Robot: 1000</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
            <div class="thinking">Thinking...</div>
        </div>
        <div class="robot robot-3">
            <p>Robot: 1000</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
            <div class="thinking">Thinking...</div>
        </div>
        <div class="pot">
            <p>Pot: 0</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
                <div class="card">?</div>
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
        </div>
        <div class="player">
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <p class="player-info">Falatka: 1000</p>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
        </div>
    </div>
    
    <!-- Create a dedicated container for all buttons -->
    <div class="buttons-container">
        <div class="action-buttons" style="display: none;">
            <button id="check-button" onclick="playerCheck()">Check</button>
            <button id="call-button" onclick="playerCall()">Call</button>
            <button id="raise-button" onclick="playerRaise()">Raise</button>
            <button id="fold-button" onclick="playerFold()">Fold</button>
        </div>
        <button id="new-game-button" onclick="startNewGame()">New Game</button>
    </div>
    <div class="game-message"></div>
</body>
</html>
