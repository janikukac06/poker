<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Póker Tanuló</title>
    <style>
        /* Main layout */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #006633;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .table {
            width: 800px;
            height: 600px;
            background-color: #008844;
            border-radius: 200px;
            border: 15px solid #553311;
            position: relative;
            padding: 20px;
        }
        .robot, .player {
            position: absolute;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            color: white;
        }
        .robot-1 {
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
        }
        .robot-2 {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .robot-3 {
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
        }
        .player {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .cards {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .card {
            width: 60px;
            height: 80px;
            background-color: white;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            font-weight: bold;
            font-size: 30px;
        }
        .card-back {
            background-image: linear-gradient(45deg, #5a8cc5 25%, #36648b 25%, #36648b 50%, #5a8cc5 50%, #5a8cc5 75%, #36648b 75%, #36648b 100%);
            background-size: 20px 20px;
            color: transparent !important;
        }
        .player-info {
            margin-top: 5px;
        }
        .dealer-button {
            width: 30px;
            height: 30px;
            background-color: white;
            border-radius: 50%;
            color: black;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
        }
        .player .dealer-button {
            bottom: 60px;
            right: -15px;
        }
        .robot .dealer-button {
            top: 60px;
            right: -15px;
        }
        .blind {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
            font-size: 12px;
        }
        .small-blind {
            background-color: white;
            color: black;
        }
        .big-blind {
            background-color: red;
            color: white;
        }
        .player .blind {
            bottom: 60px;
            left: -15px;
        }
        .robot .blind {
            top: 60px;
            left: -15px;
        }
        .bet-amount {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            color: yellow;
        }
        .player .bet-amount {
            top: -30px;
        }
        .robot .bet-amount {
            bottom: -30px;
        }
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .active-player {
            border: 3px solid red;
            border-radius: 10px;
            padding: 5px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        .thinking {
            position: absolute;
            font-weight: bold;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
        }
        .robot .thinking {
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
        }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            display: none;
            text-align: center;
            z-index: 100;
            max-width: 80%;
        }
        /* Adjust sizes for smaller viewport */
        @media (max-width: 914px), (max-height: 412px) {
            .table {
                width: 600px;
                height: 320px;
                border-radius: 120px;
            }
            
            .robot, .player {
                font-size: 12px;
                padding: 5px;
                width: 110px;
            }
            
            .card {
                width: 30px;
                height: 45px;
                font-size: 14px;
            }
            
            .dealer-button, .blind {
                width: 16px;
                height: 16px;
                font-size: 10px;
            }
            
            .action-buttons {
                bottom: 65px;
            }
            
            .controls {
                bottom: -40px;
            }
            
            .pot {
                top: 42%;
            }
        }
    </style>
    <script>
        // Card definitions
        const suits = ['♥', '♦', '♠', '♣'];
        const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        let deck = [];
        let communityCards = [];
        
        // Players array - contains all players (human and robots)
        let players = [
            {
                name: "Falatka",
                isRobot: false,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 0, // Bottom position
                folded: false,
                isActedInCurrentRound: false,
                element: '.player',
                dealerButton: '.player .dealer-button',
                blindIndicator: '.player .blind',
                betIndicator: '.player .bet-amount'
            },
            {
                name: "Robot1",
                isRobot: true,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 1, // Left position
                folded: false,
                isActedInCurrentRound: false,
                element: '.robot-1',
                dealerButton: '.robot-1 .dealer-button',
                blindIndicator: '.robot-1 .blind',
                betIndicator: '.robot-1 .bet-amount',
                thinking: '.robot-1 .thinking'
            },
            {
                name: "Robot2",
                isRobot: true,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 2, // Top position
                folded: false,
                isActedInCurrentRound: false,
                element: '.robot-2',
                dealerButton: '.robot-2 .dealer-button',
                blindIndicator: '.robot-2 .blind',
                betIndicator: '.robot-2 .bet-amount',
                thinking: '.robot-2 .thinking'
            },
            {
                name: "Robot3",
                isRobot: true,
                chips: 1000,
                cards: [],
                bet: 0,
                position: 3, // Right position
                folded: false,
                isActedInCurrentRound: false,
                element: '.robot-3',
                dealerButton: '.robot-3 .dealer-button',
                blindIndicator: '.robot-3 .blind',
                betIndicator: '.robot-3 .bet-amount',
                thinking: '.robot-3 .thinking'
            }
        ];
        
        // Game state
        let dealerIndex = 0;      // Index of the dealer in the players array
        let smallBlindIndex = 0;  // Index of the small blind in the players array
        let bigBlindIndex = 0;    // Index of the big blind in the players array
        let activePlayerIndex = 0;// Index of the active player in the players array
        let smallBlindAmount = 10;
        let bigBlindAmount = 20;
        let potAmount = 0;
        let currentBettingRound = 'none'; // none, preflop, flop, turn, river, showdown
        let isPlayerTurn = false; // Track if it's the human player's turn
        
        // Create and shuffle the deck
        function initializeDeck() {
            deck = [];
            // Create the deck
            for (let suit of suits) {
                for (let value of values) {
                    deck.push({ suit, value });
                }
            }
            // Shuffle the deck
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        // Deal cards to players
        function dealCards() {
            // Reset hands and community cards
            communityCards = [];
            
            // Reset player cards
            players.forEach(player => {
                player.cards = [];
                player.folded = false;
            });
            
            // Deal 2 cards to each player
            for (let i = 0; i < 2; i++) {
                for (let player of players) {
                    player.cards.push(deck.pop());
                }
            }
            
            // Update the UI
            updatePlayerCards();
            console.log("Players after dealing cards:", JSON.parse(JSON.stringify(players)));
        }
        
        // Start a new game
        function startNewGame() {
            // Reset game state
            potAmount = 0;
            
            // Reset all player chips and bets
            players.forEach(player => {
                player.chips = 1000;
                player.bet = 0;
                player.folded = false;
            });
            
            // Randomly select dealer position
            dealerIndex = Math.floor(Math.random() * players.length);
            
            // Set small blind and big blind positions (clockwise)
            smallBlindIndex = (dealerIndex + 1) % players.length;
            bigBlindIndex = (dealerIndex + 2) % players.length;
            
            // Set the first player to act (after big blind)
            activePlayerIndex = (bigBlindIndex + 1) % players.length;
            
            // Initialize the deck and deal cards
            initializeDeck();
            dealCards();
            
            // Place blinds
            placeBlinds();
            
            // Update UI
            updateChips();
            updateDealerButton();
            updateBlinds();
            
            // Start preflop betting round
            currentBettingRound = 'preflop';
            
            // Set active player
            setActivePlayer(activePlayerIndex);
            
            // If robot is first to act, trigger its action
            if (players[activePlayerIndex].isRobot) {
                robotActionWithDelay();
            }
            
            // Enable betting buttons if it's player's turn
            updateActionButtons();
        }
        
        // Place blinds based on dealer position
        function placeBlinds() {
            // Reset all bets
            players.forEach(player => {
                player.bet = 0;
                player.isActedInCurrentRound = false;
            });
            
            // Small blind
            players[smallBlindIndex].chips -= smallBlindAmount;
            players[smallBlindIndex].bet = smallBlindAmount;
            
            // Big blind
            players[bigBlindIndex].chips -= bigBlindAmount;
            players[bigBlindIndex].bet = bigBlindAmount;
            
            // Calculate pot amount
            potAmount = calculatePotAmount();
            
            updateChips();
            console.log("Players after placing blinds:", JSON.parse(JSON.stringify(players)));
        }
        
        // Calculate total pot amount from all player bets
        function calculatePotAmount() {
            return players.reduce((total, player) => total + player.bet, 0);
        }
        
        // Update the chips display
        function updateChips() {
            // Update player chips display
            players.forEach(player => {
                if (!player.isRobot) {
                    document.querySelector('.player-info').textContent = `${player.name}: ${player.chips}`;
                } else {
                    document.querySelector(`${player.element} p`).textContent = `${player.name}: ${player.chips}`;
                }
                
                // Update bet amounts
                let betElement = document.querySelector(player.betIndicator);
                if (player.bet > 0) {
                    betElement.textContent = player.bet;
                    betElement.style.display = 'block';
                } else {
                    betElement.style.display = 'none';
                }
            });
            
            // Update pot amount
            document.querySelector('.pot p').textContent = `Pot: ${potAmount}`;
        }
        
        // Update dealer button position
        function updateDealerButton() {
            // Hide all dealer buttons
            players.forEach(player => {
                document.querySelector(player.dealerButton).style.display = 'none';
            });
            
            // Show dealer button for the dealer
            document.querySelector(players[dealerIndex].dealerButton).style.display = 'flex';
        }
        
        // Update blinds indicators
        function updateBlinds() {
            // Hide all blind indicators first
            players.forEach(player => {
                document.querySelector(player.blindIndicator).style.display = 'none';
            });
            
            // Show small blind indicator
            let sbIndicator = document.querySelector(players[smallBlindIndex].blindIndicator);
            sbIndicator.textContent = 'SB';
            sbIndicator.classList.add('small-blind');
            sbIndicator.classList.remove('big-blind');
            sbIndicator.style.display = 'flex';
            
            // Show big blind indicator
            let bbIndicator = document.querySelector(players[bigBlindIndex].blindIndicator);
            bbIndicator.textContent = 'BB';
            bbIndicator.classList.remove('small-blind');
            bbIndicator.classList.add('big-blind');
            bbIndicator.style.display = 'flex';
        }
        
        // Set active player (visual indicator)
        function setActivePlayer(index) {
            console.log(`setActivePlayer: Setting player ${players[index].name} as active`);
            // Prevent setting a folded player as active
            if (players[index].folded) {
                console.log(`Attempted to set folded player ${players[index].name} as active. Finding next valid player.`);
                // Find the next non-folded player
                let nextValidIndex = index;
                let count = 0;
                
                // Loop through players until finding one that hasn't folded
                // Limited by player count to prevent infinite loop
                while (count < players.length) {
                    nextValidIndex = (nextValidIndex + 1) % players.length;
                    if (!players[nextValidIndex].folded) {
                        break;
                    }
                    count++;
                }
                
                // If all players are folded except one, the game is over
                if (count >= players.length - 1) {
                    const winner = players.find(p => !p.folded);
                    if (winner) {
                        winner.chips += potAmount;
                        potAmount = 0;
                        updateChips();
                        showGameMessage(`${winner.name} wins ${potAmount} chips!`);
                        console.log("Game over, everyone folded except:", winner.name);
                        document.querySelector('.action-buttons').style.display = 'none';
                        return;
                    }
                }
                
                // Set the non-folded player as active
                index = nextValidIndex;
                console.log(`Setting next valid player ${players[index].name} as active instead`);
            }
            
            activePlayerIndex = index;
            isPlayerTurn = !players[activePlayerIndex].isRobot;
            
            // Remove active-player class from all players
            players.forEach(player => {
                document.querySelector(player.element).classList.remove('active-player');
            });
            
            // Hide all thinking indicators
            players.filter(p => p.isRobot).forEach(robot => {
                document.querySelector(robot.thinking).style.display = 'none';
            });
            
            // Add active-player class to the active player
            document.querySelector(players[activePlayerIndex].element).classList.add('active-player');
            
            // If active player is a robot, show thinking indicator
            if (players[activePlayerIndex].isRobot) {
                document.querySelector(players[activePlayerIndex].thinking).style.display = 'block';
                
                // Disable player action buttons while robot is thinking
                document.querySelectorAll('.action-buttons button').forEach(button => {
                    button.disabled = true;
                });
            } else {
                // Enable player action buttons
                document.querySelectorAll('.action-buttons button').forEach(button => {
                    button.disabled = false;
                });
            }
        }
        
        // Move to the next player in turn
        function nextPlayer() {
            console.log("nextPlayer");
            // Mark current player as having acted in this round
            players[activePlayerIndex].isActedInCurrentRound = true;
            console.log(`Player ${players[activePlayerIndex].name} has acted this round`);
                        
            // Find next player that hasn't folded
            let nextIndex = (activePlayerIndex + 1) % players.length;
            let count = 0;
            
            // Skip folded players, but prevent infinite loops
            while (players[nextIndex].folded && count < players.length) {
                nextIndex = (nextIndex + 1) % players.length;
                count++;
            }
            
            // Check if all non-folded players have called the highest bet
            const highestBet = Math.max(...players.map(p => p.bet));
            const nonFoldedPlayers = players.filter(p => !p.folded);
            
            // If all active players have the same bet amount, move to next round
            const allBetsEqual = nonFoldedPlayers.every(p => p.bet === highestBet);

            // Check if all non-folded players have acted in this round
            const allPlayersActed = nonFoldedPlayers.every(p => p.isActedInCurrentRound);
            
            console.log("All bets equal:", allBetsEqual, "All players acted:", allPlayersActed);
            console.log("Active players:", nonFoldedPlayers.map(p => `${p.name}: bet=${p.bet}, acted=${p.isActedInCurrentRound}`));
            
            if (allBetsEqual && allPlayersActed) {
                // All players have matched the bet, move to next round
                console.log("All bets equal, advancing to next round");
                advanceToNextRound();
                return;
            }
            
            setActivePlayer(nextIndex);
            console.log("Next player:", nextIndex, "Active player is robot:", players[nextIndex].isRobot);
            
            // If next player is a robot, trigger its action
            if (players[nextIndex].isRobot) {
                robotActionWithDelay();
            }
        }

        // Update player cards in the UI
        function updatePlayerCards() {
            // Update human player's cards
            const humanPlayer = players.find(p => !p.isRobot);
            const playerCardElements = document.querySelectorAll('.player .card');
            
            if (humanPlayer.cards.length === 2) {
                playerCardElements[0].textContent = `${humanPlayer.cards[0].value}${humanPlayer.cards[0].suit}`;
                playerCardElements[1].textContent = `${humanPlayer.cards[1].value}${humanPlayer.cards[1].suit}`;
                
                // Apply color for hearts and diamonds
                playerCardElements.forEach((cardEl, index) => {
                    if (humanPlayer.cards[index].suit === '♥' || humanPlayer.cards[index].suit === '♦') {
                        cardEl.classList.add('red-card');
                    } else {
                        cardEl.classList.remove('red-card');
                    }
                });
            } else {
                playerCardElements.forEach(card => {
                    card.textContent = '?';
                    card.classList.remove('red-card');
                });
            }
            
            // Set robot cards to hidden state (unless revealed)
            players.filter(p => p.isRobot).forEach((robot, robotIndex) => {
                const robotCards = document.querySelectorAll(`${robot.element} .card`);
                
                if (robot.folded) {
                    // If robot has folded, show empty cards
                    robotCards.forEach(card => {
                        card.textContent = '';
                        card.classList.remove('card-back');
                        card.classList.remove('red-card');
                        card.style.backgroundImage = 'none';
                        card.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                    });
                } else {
                    // If robot is active, show card backs with gradient
                    robotCards.forEach(card => {
                        card.textContent = '';
                        card.classList.add('card-back');
                        card.classList.remove('red-card');
                    });
                }
            });
        }
        
        // Player actions
        function playerCheck() {
            // Player can only check if no one has bet more
            const highestBet = Math.max(...players.map(p => p.bet));
            
            if (players[activePlayerIndex].bet >= highestBet) {
                console.log("Player checks");
                nextPlayer(); // Move to next player's turn
            }
        }
        
        function playerCall() {
            const humanPlayerIndex = players.findIndex(p => !p.isRobot);
            const highestBet = Math.max(...players.map(p => p.bet));
            const callAmount = highestBet - players[humanPlayerIndex].bet;
            
            // Update chips and bet
            players[humanPlayerIndex].chips -= callAmount;
            players[humanPlayerIndex].bet = highestBet;
            
            // Update pot
            potAmount = calculatePotAmount();
            
            updateChips();
            console.log("Player calls, new bet:", players[humanPlayerIndex].bet);
            nextPlayer();
        }
        
        function playerRaise() {
            const humanPlayerIndex = players.findIndex(p => !p.isRobot);
            const highestBet = Math.max(...players.map(p => p.bet));
            const raiseAmount = bigBlindAmount;
            const totalBet = highestBet + raiseAmount;
            const amountToAdd = totalBet - players[humanPlayerIndex].bet;
            
            // Update chips and bet
            players[humanPlayerIndex].chips -= amountToAdd;
            players[humanPlayerIndex].bet = totalBet;
            
            // Update pot
            potAmount = calculatePotAmount();
            
            updateChips();
            console.log("Player raises to:", players[humanPlayerIndex].bet);
            
            nextPlayer(); // Move to next player
        }
        
        function playerFold() {
            const humanPlayerIndex = players.findIndex(p => !p.isRobot);
            players[humanPlayerIndex].folded = true;
            console.log("Player folds");
            
            // Check if only one player remains
            const activePlayers = players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                // Award pot to the remaining player
                activePlayers[0].chips += potAmount;
                potAmount = 0;
                
                updateChips();
                showGameMessage(`${activePlayers[0].name} wins ${potAmount} chips!`);
                console.log("Game over, winner:", activePlayers[0].name);
                
                // Disabled buttons until next game
                document.querySelectorAll('.action-buttons button').forEach(button => {
                    button.disabled = true;
                });
                
                // Hide action buttons
                document.querySelector('.action-buttons').style.display = 'none';
                
                return;
            }
            
            nextPlayer(); // Move to next player
        }
        
        // Apply a random delay to robot's action
        function robotActionWithDelay() {
            console.log("robotActionWithDelay");
            // Only proceed if active player is a robot
            if (!players[activePlayerIndex].isRobot) return;
            
            const delay = 1000 + Math.random() * 1000; // 1-2 second delay
            setTimeout(robotAction, delay);
        }
        
        // Simple robot AI
        function robotAction() {
            console.log("robotAction");
            if (!players[activePlayerIndex].isRobot) return;
            
            const robot = players[activePlayerIndex];
            const highestBet = Math.max(...players.map(p => p.bet));
            const callAmount = highestBet - robot.bet;
            
            // Simple AI logic - randomize decisions
            const random = Math.random();
            
            if (callAmount === 0) {
                // Can check
                if (random < 0.7) {
                    // Check (70% chance)
                    console.log(`${robot.name} checks`);
                    // Robot action flag is set in nextPlayer()
                    nextPlayer();
                } else {
                    // Raise (30% chance)
                    console.log(`${robot.name} raises`);
                    const raiseAmount = bigBlindAmount;
                    robot.chips -= raiseAmount;
                    robot.bet += raiseAmount;
                    
                    // When robot raises, all other players need to act again
                    players.forEach(player => {
                        if (player !== robot && !player.folded) {
                            player.isActedInCurrentRound = false;
                        }
                    });
                    
                    potAmount = calculatePotAmount();
                    updateChips();
                    console.log("Robot state after raising:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                }
            } else {
                // Need to call or raise
                if (callAmount >= robot.chips) {
                    // All-in
                    console.log(`${robot.name} is all-in`);
                    robot.bet += robot.chips;
                    robot.chips = 0;
                    potAmount = calculatePotAmount();
                    updateChips();
                    console.log("Robot state after going all-in:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                } else if (random < 0.5) {
                    // Fold (50% chance if need to call)
                    console.log(`${robot.name} folds`);
                    robot.folded = true;
                    updatePlayerCards();
                    
                    // Check if only one player remains
                    const activePlayers = players.filter(p => !p.folded);
                    if (activePlayers.length === 1) {
                        // Award pot to the remaining player
                        activePlayers[0].chips += potAmount;
                        potAmount = 0;
                        
                        updateChips();
                        showGameMessage(`${activePlayers[0].name} wins the pot!`);
                        console.log("Game over, winner:", activePlayers[0].name);
                        
                        // Hide action buttons
                        document.querySelector('.action-buttons').style.display = 'none';
                        
                        setTimeout(startNewGame, 3000);
                        return;
                    }
                    
                    nextPlayer();
                } else if (random < 0.9) {
                    // Call (40% chance if need to call)
                    console.log(`${robot.name} calls ${callAmount}`);
                    robot.chips -= callAmount;
                    robot.bet = highestBet;
                    potAmount = calculatePotAmount();
                    updateChips();
                    console.log("Robot state after calling:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                } else {
                    // Raise (10% chance if need to call)
                    console.log(`${robot.name} raises`);
                    const raiseAmount = callAmount + bigBlindAmount;
                    
                    if (raiseAmount >= robot.chips) {
                        // All-in
                        robot.bet += robot.chips;
                        robot.chips = 0;
                    } else {
                        robot.chips -= raiseAmount;
                        robot.bet = highestBet + bigBlindAmount;
                    }
                    
                    // When robot raises, all other players need to act again
                    players.forEach(player => {
                        if (player !== robot && !player.folded) {
                            player.isActedInCurrentRound = false;
                        }
                    });
                    
                    potAmount = calculatePotAmount();
                    updateChips();
                    console.log("Robot state after raising:", JSON.parse(JSON.stringify(robot)));
                    nextPlayer();
                }
            }
        }
        
        // Advance to the next betting round
        function advanceToNextRound() {
            console.log("advanceToNextRound");
            // Move bets to pot and reset current bets
            players.forEach(player => {
                player.bet = 0;
                player.isActedInCurrentRound = false;
            });
            
            switch (currentBettingRound) {
                case 'preflop':
                    // Deal the flop
                    dealFlop();
                    currentBettingRound = 'flop';
                    break;
                case 'flop':
                    // Deal the turn
                    dealTurn();
                    currentBettingRound = 'turn';
                    break;
                case 'turn':
                    // Deal the river
                    dealRiver();
                    currentBettingRound = 'river';
                    break;
                case 'river':
                    // Show down - evaluate hands and determine winner
                    currentBettingRound = 'showdown';
                    showdown();
                    // Start a new hand after a brief delay
                    setTimeout(startNewGame, 3000);
                    return;
            }
            
            updateChips();
            
            // Set active player (acts first player after the dealer after the flop)
            if (currentBettingRound !== 'showdown') {
                setActivePlayer((dealerIndex + 1) % players.length);
            }
            
            updateActionButtons();
            console.log("Advanced to betting round:", currentBettingRound);
            console.log("Players state:", JSON.parse(JSON.stringify(players)));
        }
        
        // Update action buttons based on game state
        function updateActionButtons() {
            const actionButtons = document.querySelector('.action-buttons');
            
            if (currentBettingRound === 'none' || currentBettingRound === 'showdown') {
                actionButtons.style.display = 'none';
            } else {
                actionButtons.style.display = 'flex';
                
                // Enable/disable buttons based on context
                const checkButton = document.getElementById('check-button');
                const callButton = document.getElementById('call-button');
                
                if (players[activePlayerIndex].bet < Math.max(...players.map(p => p.bet))) {
                    // Can't check if robot has bet more
                    checkButton.disabled = true;
                    callButton.disabled = false;
                } else {
                    checkButton.disabled = false;
                    callButton.disabled = true;
                }
                
                // If it's not player's turn, disable all buttons
                if (!isPlayerTurn) {
                    document.querySelectorAll('.action-buttons button').forEach(button => {
                        button.disabled = true;
                    });
                }
            }
        }

        // Reveal the robot's cards
        function revealRobotCards() {
            const robotCardElements = document.querySelectorAll('.robot .card');
            
            // Reset all cards to hide first
            robotCardElements.forEach(card => {
                card.innerHTML = '?';
                card.classList.add('card-back');
                card.style.color = 'white';
            });
            
            // Now reveal the correct cards for each robot
            for (let r = 0; r < 3; r++) {
                const robotHand = players[r+1].cards;
                if (!robotHand || robotHand.length === 0) continue;
                
                for (let c = 0; c < robotHand.length; c++) {
                    const card = robotHand[c];
                    const cardElement = document.querySelector(`.robot-${r+1} .card:nth-child(${c+1})`);
                    
                    if (cardElement && card) {
                        const color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                        cardElement.innerHTML = `${card.value}${card.suit}`;
                        cardElement.style.color = color;
                        cardElement.classList.remove('card-back');
                    }
                }
            }
        }

        // Show game result message
        function showGameMessage(message) {
            const gameMessage = document.querySelector('.game-message');
            // Clear any previous content
            gameMessage.innerHTML = '';
            
            // Add message text
            const messageText = document.createElement('div');
            messageText.textContent = message;
            gameMessage.appendChild(messageText);
            
            // Add a button to close the message and a button to start a new game
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '15px';
            buttonContainer.style.display = 'flex';
            buttonContainer.style.justifyContent = 'center';
            buttonContainer.style.gap = '10px';
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.onclick = function() { 
                gameMessage.style.display = 'none';
            };
            closeBtn.style.padding = '5px 10px';
            closeBtn.style.backgroundColor = '#e74c3c';
            closeBtn.style.border = 'none';
            closeBtn.style.borderRadius = '3px';
            closeBtn.style.color = 'white';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.style.cursor = 'pointer';
            
            const newGameBtn = document.createElement('button');
            newGameBtn.textContent = 'New Game';
            newGameBtn.onclick = function() {
                gameMessage.style.display = 'none';
                startNewGame();
            };
            newGameBtn.style.padding = '5px 10px';
            newGameBtn.style.backgroundColor = '#2ecc71';
            newGameBtn.style.border = 'none';
            newGameBtn.style.borderRadius = '3px';
            newGameBtn.style.color = 'white';
            newGameBtn.style.fontWeight = 'bold';
            newGameBtn.style.cursor = 'pointer';
            
            buttonContainer.appendChild(closeBtn);
            buttonContainer.appendChild(newGameBtn);
            gameMessage.appendChild(buttonContainer);
            
            // Display the message
            gameMessage.style.display = 'block';
        }

        // Showdown - determine winner
        function showdown() {
            // For now, just reveal cards and give pot to a random winner
            revealRobotCards();
            
            setTimeout(() => {
                const randomWinner = Math.random() > 0.5;
                if (randomWinner) {
                    showGameMessage("Falatka wins the pot!");
                    players[0].chips += potAmount;
                } else {
                    showGameMessage("Robot wins the pot!");
                    players[1].chips += potAmount;
                }
                potAmount = 0;
                updateChips();
                
                // Start a new game
                setTimeout(startNewGame, 1500);
            }, 2000);
        }

        // Deal the flop (first 3 community cards)
        function dealFlop() {
            // Burn a card (discard)
            deck.pop();
            
            // Deal 3 community cards
            for (let i = 0; i < 3; i++) {
                communityCards.push(deck.pop());
            }
            
            updateCommunityCards();
            console.log("Flop dealt:", JSON.parse(JSON.stringify(communityCards)));
        }

        // Deal the turn (4th community card)
        function dealTurn() {
            // Burn a card
            deck.pop();
            
            // Deal the turn card
            communityCards.push(deck.pop());
            
            updateCommunityCards();
            console.log("Turn dealt:", JSON.parse(JSON.stringify(communityCards)));
        }

        // Deal the river (5th community card)
        function dealRiver() {
            // Burn a card
            deck.pop();
            
            // Deal the river card
            communityCards.push(deck.pop());
            
            updateCommunityCards();
            console.log("River dealt:", JSON.parse(JSON.stringify(communityCards)));
        }
        
        // Update community cards in the UI
        function updateCommunityCards() {
            const communityCardElements = document.querySelectorAll('.pot .card');
            
            // Show revealed community cards, keep others hidden
            for (let i = 0; i < communityCardElements.length; i++) {
                if (i < communityCards.length) {
                    const card = communityCards[i];
                    communityCardElements[i].textContent = `${card.value}${card.suit}`;
                    
                    // Apply color for hearts and diamonds
                    if (card.suit === '♥' || card.suit === '♦') {
                        communityCardElements[i].classList.add('red-card');
                    } else {
                        communityCardElements[i].classList.remove('red-card');
                    }
                } else {
                    communityCardElements[i].textContent = '';
                    communityCardElements[i].classList.remove('red-card');
                }
            }
        }

        // Initialize the game when the page loads
        window.onload = function() {
            startNewGame();
        };
    </script>
</head>
<body>
    <div class="table">
        <div class="robot robot-1">
            <p>Robot: 1000</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
            <div class="thinking">Thinking...</div>
        </div>
        <div class="robot robot-2">
            <p>Robot: 1000</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
            <div class="thinking">Thinking...</div>
        </div>
        <div class="robot robot-3">
            <p>Robot: 1000</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
            <div class="thinking">Thinking...</div>
        </div>
        <div class="pot">
            <p>Pot: 0</p>
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
                <div class="card">?</div>
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
        </div>
        <div class="player">
            <div class="cards">
                <div class="card">?</div>
                <div class="card">?</div>
            </div>
            <p class="player-info">Falatka: 1000</p>
            <div class="dealer-button" style="display: none;">D</div>
            <div class="blind" style="display: none;">SB</div>
            <div class="bet-amount" style="display: none;">0</div>
        </div>
    </div>
    
    <div class="action-buttons" style="display: none; margin-top: 10px;">
        <button id="check-button" onclick="playerCheck()">Check</button>
        <button id="call-button" onclick="playerCall()">Call</button>
        <button id="raise-button" onclick="playerRaise()">Raise</button>
        <button id="fold-button" onclick="playerFold()">Fold</button>
    </div>
    
    <div class="controls" style="margin-top: 20px; text-align: center;">
        <button onclick="startNewGame()">New Game</button>
        <button onclick="revealRobotCards()">Reveal Robot's Cards</button>
    </div>
    <div class="game-message"></div>
</body>
</html>
